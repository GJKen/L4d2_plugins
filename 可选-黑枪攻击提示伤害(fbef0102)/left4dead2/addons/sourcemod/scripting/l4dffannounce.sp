/* Plugin Template generated by Pawn Studio */
#pragma semicolon 1
#pragma newdecls required //強制1.7以後的新語法

#include <sourcemod>
#include <sdktools>
#include <sdkhooks>
#include <multicolors>

#define CVAR_FLAGS				FCVAR_NOTIFY
#define MAXENTITIES 2048

public Plugin myinfo = 
{
	name = "L4D FF Announce Plugin",
	author = "Frustian & HarryPotter",
	description = "Display Friendly Fire Announcements",
	version = "1.8",
	url = "https://steamcommunity.com/profiles/76561198026784913"
}
//cvar handles
ConVar FFenabled;
ConVar AnnounceType;

//Various global variables
int DamageCache[MAXPLAYERS+1][MAXPLAYERS+1]; //Used to temporarily store Friendly Fire Damage between teammates
Handle FFTimer[MAXPLAYERS+1]; //Used to be able to disable the FF timer when they do more FF

public APLRes AskPluginLoad2(Handle myself, bool late, char[] error, int err_max) 
{
	EngineVersion test = GetEngineVersion();
	
	if( test != Engine_Left4Dead2 && test != Engine_Left4Dead) 
	{
		strcopy(error, err_max, "Plugin only supports Left 4 Dead 1 & 2.");
		return APLRes_SilentFailure;
	}

	return APLRes_Success; 
}

public void OnPluginStart()
{
	LoadTranslations("l4dffannounce.phrases");
	FFenabled = CreateConVar("l4d_ff_announce_enable", "1", "Enable Announcing Friendly Fire",CVAR_FLAGS);
	AnnounceType = CreateConVar("l4d_ff_announce_type", "1", "Changes how ff announce displays FF damage (1:In chat; 2: In Hint Box; 3: In center text)",CVAR_FLAGS);
	
	HookEvent("player_hurt_concise", Event_HurtConcise, EventHookMode_Post);
	HookEvent("player_incapacitated_start", Event_IncapacitatedStart);

	HookEvent("player_death", Event_PlayerDeath);
	HookEvent("round_end",				Event_RoundEnd,		EventHookMode_PostNoCopy); //trigger twice in versus mode, one when all survivors wipe out or make it to saferom, one when first round ends (second round_start begins).
	HookEvent("map_transition", 		Event_RoundEnd,		EventHookMode_PostNoCopy); //all survivors make it to saferoom, and server is about to change next level in coop mode (does not trigger round_end) 
	HookEvent("mission_lost", 			Event_RoundEnd,		EventHookMode_PostNoCopy); //all survivors wipe out in coop mode (also triggers round_end)
	HookEvent("finale_vehicle_leaving", Event_RoundEnd,		EventHookMode_PostNoCopy); //final map final rescue vehicle leaving  (does not trigger round_end)
	
	//Autoconfig for plugin
	AutoExecConfig(true, "l4dffannounce");
}

public void OnMapEnd()
{
	ResetTimer();
}

public void Event_RoundEnd(Event event, const char[] name, bool dontBroadcast) 
{
	ResetTimer();
}

public void Event_PlayerDeath(Event event, const char[] name, bool dontBroadcast) 
{
	int victim = GetClientOfUserId(event.GetInt("userid"));
	int attacker = GetClientOfUserId(event.GetInt("attacker"));
	if ( !victim || !IsClientInGame(victim) || attacker == victim ) return;
	if ( !attacker || !IsClientInGame(attacker) ) return;

	if(GetClientTeam(attacker) == 2 && GetClientTeam(victim) == 2) //人類 kill &友傷
	{
		// CPrintToChatAll("[{olive}TS{default}] %t", "KILL", attacker, victim); // 前面带[TS]提示的代码
		CPrintToChatAll("%t", "KILL", attacker, victim);
	}	
}

public void Event_HurtConcise(Event event, const char[] name, bool dontBroadcast) 
{
	int attacker = event.GetInt("attackerentid");
	int victim = GetClientOfUserId(event.GetInt("userid"));
	if (FFenabled.BoolValue == false || 
	attacker == victim ||
	attacker > MaxClients || 
	attacker < 1 || 
	!IsClientInGame(attacker) || 
	IsFakeClient(attacker) || 
	GetClientTeam(attacker) != 2 || 
	!IsClientInGame(victim) || 
	GetClientTeam(victim) != 2)
		return;  
	
	int damage = event.GetInt("dmg_health");
	if (FFTimer[attacker] != null)  //If the player is already friendly firing teammates, resets the announce timer and adds to the damage
	{
		DamageCache[attacker][victim] += damage;
		delete FFTimer[attacker];
		FFTimer[attacker] = CreateTimer(1.0, AnnounceFF, attacker);
	}
	else //If it's the first friendly fire by that player, it will start the announce timer and store the damage done.
	{
		DamageCache[attacker][victim] = damage;
		delete FFTimer[attacker];
		FFTimer[attacker] = CreateTimer(1.0, AnnounceFF, attacker);
		for (int i = 1; i <= MaxClients; i++)
		{
			if (i != attacker && i != victim)
			{
				DamageCache[attacker][i] = 0;
			}
		}
	}
}

public void Event_IncapacitatedStart(Event event, const char[] name, bool dontBroadcast) 
{
	int victim = GetClientOfUserId(event.GetInt("userid"));
	int attacker = GetClientOfUserId(event.GetInt("attacker"));

	if (FFenabled.BoolValue == false || 
	attacker == victim ||
	attacker > MaxClients || 
	attacker < 1 || 
	!IsClientInGame(attacker) || 
	IsFakeClient(attacker) || 
	GetClientTeam(attacker) != 2 || 
	!IsClientInGame(victim) || 
	GetClientTeam(victim) != 2)
		return;  

	int damage = GetClientHealth(victim) + RoundToFloor(GetTempHealth(victim));
	if (FFTimer[attacker] != null)  //If the player is already friendly firing teammates, resets the announce timer and adds to the damage
	{
		DamageCache[attacker][victim] += damage;
		delete FFTimer[attacker];
		FFTimer[attacker] = CreateTimer(1.0, AnnounceFF, attacker);
	}
	else //If it's the first friendly fire by that player, it will start the announce timer and store the damage done.
	{
		DamageCache[attacker][victim] = damage;
		delete FFTimer[attacker];
		FFTimer[attacker] = CreateTimer(1.0, AnnounceFF, attacker);
		for (int i = 1; i <= MaxClients; i++)
		{
			if (i != attacker && i != victim)
			{
				DamageCache[attacker][i] = 0;
			}
		}
	}
}

public Action AnnounceFF(Handle timer, int attackerc) //Called if the attacker did not friendly fire recently, and announces all FF they did
{
	char victim[128];
	char attacker[128];

	if (IsClientInGame(attackerc) && !IsFakeClient(attackerc))
		GetClientName(attackerc, attacker, sizeof(attacker));
	else
		attacker = "Disconnected Player";

	for (int i = 1; i <= MaxClients; i++)
	{
		if (DamageCache[attackerc][i] != 0 && attackerc != i)
		{
			if (IsClientInGame(i))
			{
				GetClientName(i, victim, sizeof(victim));
				switch(AnnounceType.IntValue)
				{
					case 1:
					{
						if (IsClientInGame(attackerc) && !IsFakeClient(attackerc))
							CPrintToChat(attackerc, "%T", "FF_dealt (C)", attackerc, DamageCache[attackerc][i], victim);
						if (IsClientInGame(i) && !IsFakeClient(i))
							CPrintToChat(i, "%T", "FF_receive (C)", i, attacker, DamageCache[attackerc][i]);
					}
					case 2:
					{
						if (IsClientInGame(attackerc) && !IsFakeClient(attackerc))
							PrintHintText(attackerc, "%T", "FF_dealt", attackerc, DamageCache[attackerc][i],victim);
						if (IsClientInGame(i) && !IsFakeClient(i))
							PrintHintText(i, "%T", "FF_receive", i, attacker, DamageCache[attackerc][i]);
					}
					case 3:
					{
						if (IsClientInGame(attackerc) && !IsFakeClient(attackerc))
							PrintCenterText(attackerc, "%T", "FF_dealt", attackerc, DamageCache[attackerc][i], victim);
						if (IsClientInGame(i) && !IsFakeClient(i))
							PrintCenterText(i, "%T", "FF_receive", i, attacker, DamageCache[attackerc][i]);
					}
				}
			}
			DamageCache[attackerc][i] = 0;
		}
	}

	FFTimer[attackerc] = null;
	return Plugin_Continue;
}

void ResetTimer()
{
	for (int i = 1; i <= MaxClients; i++)
	{
		delete FFTimer[i];
	}
}

stock float GetTempHealth(int client)
{
	static float fCvarDecayRate = -1.0;

	if (fCvarDecayRate == -1.0)
		fCvarDecayRate = FindConVar("pain_pills_decay_rate").FloatValue;

	float fTempHealth = GetEntPropFloat(client, Prop_Send, "m_healthBuffer");
	fTempHealth -= (GetGameTime() - GetEntPropFloat(client, Prop_Send, "m_healthBufferTime")) * fCvarDecayRate;
	return fTempHealth < 0.0 ? 0.0 : fTempHealth;
}
